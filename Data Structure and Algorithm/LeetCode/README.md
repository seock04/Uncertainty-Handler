# This is a list of leet code problems that I solved to practice algorithm

## 2021 March
* [1.1 Distributes Candy](./Distributes%20Candy.cpp)
* [2.2 Is Subsequence](./Is%20Subsequence.cpp)
* [3.0 Palindrome Partitioning](./Palindrome%20Partitioning.cpp)
* [4.3 Missing Number](./Missing%20Number.cpp)
  * good to learn, 0~n sum and xor logic
* [5.4 Intersection of Two Linked Lists](./Intersection%20of%20Two%20Linked%20Lists.cpp)
  * linked list, stack, hash map
* [6.0 Average of Levels in Binary Tree](./Average%20of%20Levels%20in%20Binary%20Tree.cpp)
  * BFS, Tree
* [7.0 Short Encoding of Words](./Short%20Encoding%20of%20Words.cpp)
  * string hash map
* [8.0 Generate parentheses](./Generate%20parentheses.cpp)
  * recursion 
* [9.5 Design HashMap](./Design%20HashMap.cpp)
* [10.6 Remove Palindromic Subsequence](./Remove%20Palindromic%20Subsequences.cpp)
  * string
* [11.7 Add One Row to Tree](./Add%20One%20Row%20to%20Tree.cpp)
  * BFS - level 
* [12.0 Check if a String contains all binary codes](./Check%20If%20a%20String%20Contains%20All%20Binary%20Codes%20of%20Size%20K.cpp)
  * set, substr 
* [13.0 Coin Change](./Coin%20Change.cpp)
  * dp bottom-up
* [14.0 Integer to Roman](./Integer%20to%20Roman.cpp)
  * map, reverse iterator
* [15.8 Swapping Nodes in a Linked List](./Swapping%20Nodes%20in%20a%20Linked%20List.cpp)
  * Linked List

## 2021 Feb
* [1.0 Container with Most Water Code](./Container%20With%20Most%20Water.cpp)
* [2.0 Copy List with Random Pointer](./Copy%20List%20with%20Random%20Pointer.cpp)
* [3.0 Letter Case Permutation](./Letter%20Case%20Permutation.cpp)
* [4.0 Min Cost Climbing Stairs](./Min%20Cost%20Climbing%20Stairs.cpp)
* [5.0 Minimum Falling Path Sum](./Minimum%20Falling%20Path%20Sum.cpp)
* [6.0 Shortest distance to character](./Shortest%20distance%20to%20character.cpp)
* [7.0 Shortest path in binary matrix](./Shortest%20path%20in%20binary%20matrix.cpp)
  * use BFS for shortest path
* [8.0 Subsets](./Subsets.cpp)
* [9.0 The K Weakest Rows in a Matrix](./The%20K%20Weakest%20Rows%20in%20a%20Matrix.cpp)
* [10.0 Divisor Game](./Divisor%20Game.cpp)
  * dp problem
* [11.0 Minimum Remove to Make Valid Parentheses](./Minimum%20Remove%20to%20Make%20Valid%20Parentheses.cpp)
  * string manipulation with parentheses 
* [12.0 Roman to Integer](./Roman%20to%20Integer.cpp)
* [13.0 3Sum Closest](./3Sum%20Closest.cpp)
* [14.0 Broken Calculator](./Broken%20Calculator.cpp)
  * think differently!, instead of handling X, handle Y for the easier calculation
* [15.0 Guess Number higher or lower](./Guess%20Number%20Higer%20or%20Lower%20ii.cpp)
  * pick the min value of max in ranges  
* [16.0 Sum Root to Leaf Numbers](./Sum%20Root%20to%20Leaf%20numbers.cpp)
  * simple binary tree travel
* [17.0 Longest Word in Dictionary through Deleting](./Longest%20Word%20in%20Dictionary%20through%20Deleting.cpp)
  * string manipulation
* [18.0 Search 2D matrix ii](.//Search%20a%202D%20Matrix%20II.cpp)
  * very good way to find value in sorted matrix
* [19.0 Score of Parentheses](./Score%20of%20Parentheses.cpp)
  * this tell me how I can calculate the operation with parentheses by using stack, must remember
* [20.0 Decode Ways](./Decode%20Ways.cpp)
  * DP - with prev, prev to prev variable 
* [21.0 Unique Binary Search Trees](./Unique%20Binary%20Search%20Trees.cpp)
  * DP - sum the all possibilities all num from 1 to n, and for each root, you should multiply all the possibility of left and right
* [22.1 House Robber](./House%20Robber.cpp)
* [23.0 Perfect Squares](./Perfect%20Square.cpp)
  * need more understanding
* [24.0 Shortest Unsorted Continuous Subarray](./Shortest%20Unsorted%20Continuous%20Subarray.cpp)
* [25.0 Validate Stack Sequence](./Validate%20Stack%20Sequences.cpp)
  * good example of using stack
* [26.0 Divide two integer](./Divide%20two%20integer.cpp)
  * bit manipulation is difficult
* [27.0 Maximum Frequency Stack](./Maximum%20Frequency%20Stack.cpp)
  * using 2 unordered_map for frequency and group of same numbers for the same frequency management






